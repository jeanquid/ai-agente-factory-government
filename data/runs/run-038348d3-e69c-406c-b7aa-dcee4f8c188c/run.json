{
  "runId": "038348d3-e69c-406c-b7aa-dcee4f8c188c",
  "tenantId": "default",
  "mission": "realiza una app de citas",
  "createdAt": "2026-02-15T03:22:31.012Z",
  "workflow": {
    "order": [
      "javier",
      "fabricio",
      "martin",
      "damian",
      "agustina"
    ],
    "currentStep": 3
  },
  "steps": [
    {
      "step": 1,
      "agentId": "javier",
      "status": "done",
      "finishedAt": "2026-02-15T03:22:52.310Z",
      "deliverables": {
        "outputJson": {
          "appName": "Conexión IA",
          "missionStatement": "Facilitar la creación de conexiones significativas y duraderas entre individuos, utilizando inteligencia artificial para optimizar la compatibilidad y la experiencia del usuario, garantizando un entorno seguro y auténtico.",
          "coreFeatures": [
            {
              "name": "profileManagement",
              "description": "Creación y gestión de perfiles detallados (fotos, biografía, intereses, hobbies, preferencias de relación)."
            },
            {
              "name": "smartMatchingEngine",
              "description": "Algoritmo de IA para sugerir matches basados en compatibilidad de intereses, valores, ubicación y preferencias definidas por el usuario."
            },
            {
              "name": "intuitiveDiscovery",
              "description": "Interfaz de exploración de perfiles (swipe) con filtros avanzados y recomendaciones personalizadas."
            },
            {
              "name": "secureMessaging",
              "description": "Chat en tiempo real, seguro y privado entre usuarios que han hecho 'match'."
            },
            {
              "name": "safetyAndModeration",
              "description": "Herramientas de reporte y bloqueo de usuarios, complementadas con un sistema de moderación proactivo impulsado por IA para detectar contenido inapropiado o comportamiento fraudulento."
            }
          ],
          "cognitiveFlowDiagram": "graph TD\n    A[Inicio/Registro] --> B{Creación de Perfil};\n    B --> C{Configuración de Preferencias};\n    C --> D[Algoritmo de Matching];\n    D --> E{Exploración de Perfiles};\n    E -- \"Swipe/Like\" --> F{Match?};\n    F -- \"Sí\" --> G[Chat entre Matches];\n    F -- \"No\" --> E;\n    G --> H[Gestión de Perfil/Interacciones];\n    H --> D;\n    H --> I[Reporte/Bloqueo];\n    I --> J[Moderación];\n    J --> H;",
          "keyAcceptanceCriteria": [
            "El 90% de los usuarios activos reporta que las sugerencias de matches son relevantes para sus preferencias explícitas.",
            "La tasa de reportes por contenido inapropiado o comportamiento fraudulento es inferior al 0.5% del total de interacciones de chat.",
            "El 85% de los usuarios que inician el proceso de registro completan la creación de su perfil y configuración de preferencias.",
            "La privacidad y seguridad de los datos del usuario están garantizadas, cumpliendo con las regulaciones de protección de datos (ej. GDPR, CCPA).",
            "El tiempo promedio para que un usuario activo reciba su primer 'match' relevante es inferior a 24 horas."
          ],
          "antiHallucinationRules": [
            {
              "ruleName": "Relevancia del Match Estricta",
              "description": "El algoritmo de matching SOLO sugerirá perfiles que cumplan con al menos el 70% de las preferencias explícitas del usuario (ej. rango de edad, distancia máxima, orientación). Si no hay suficientes perfiles que cumplan este umbral, el sistema indicará la falta de matches en lugar de sugerir perfiles irrelevantes.",
              "enforcement": "Algoritmo de IA y filtros de búsqueda."
            },
            {
              "ruleName": "Integridad y Verificación de Perfil",
              "description": "Toda la información del perfil (texto, imágenes) debe pasar por un filtro de moderación (IA y/o humana) antes de ser visible. Contenido ofensivo, explícito o engañoso será rechazado o marcado para revisión. No se permite la invención de datos de perfil. Se priorizará la implementación de verificación de identidad (ej. foto selfie con documento) para reducir perfiles falsos.",
              "enforcement": "Sistema de moderación de contenido y proceso de verificación de usuario."
            },
            {
              "ruleName": "Privacidad de Datos del Usuario",
              "description": "El sistema NUNCA compartirá información personal sensible (números de teléfono, direcciones exactas, apellidos completos) a otros usuarios a menos que sea explícitamente autorizado y configurado por el usuario. Los datos de geolocalización solo se utilizarán para el matching por distancia y no se mostrará la ubicación exacta.",
              "enforcement": "Arquitectura de seguridad de datos y controles de privacidad del usuario."
            },
            {
              "ruleName": "Comunicación Auténtica",
              "description": "El sistema de chat no permitirá el envío automático de mensajes predefinidos o generados por IA que simulen una conversación real sin intervención explícita del usuario. Cualquier sugerencia de IA para mensajes debe ser claramente identificable como tal y requerir aprobación del usuario.",
              "enforcement": "Lógica de la interfaz de chat y monitoreo de patrones de mensajería."
            }
          ]
        },
        "summaryMarkdown": "## Diseño Conceptual de \"Conexión IA\": La Mente Detrás de Tu Próxima Conexión\n\nComo Javier, \"El Cerebro\", he diseñado la arquitectura lógica y el propósito fundamental de \"Conexión IA\", una aplicación de citas innovadora. El objetivo principal es trascender la superficialidad, facilitando conexiones genuinas y duraderas mediante un motor de matching inteligente y un entorno seguro.\n\nHemos definido un flujo cognitivo claro para la interacción del usuario, desde el registro hasta el chat y la gestión de perfiles. Las características clave incluyen una gestión de perfiles robusta, un motor de matching impulsado por IA, una experiencia de descubrimiento intuitiva y, crucialmente, fuertes medidas de seguridad y moderación.\n\nSe han establecido criterios de aceptación rigurosos y \"reglas anti-alucinación\" para asegurar que el algoritmo siempre priorice la relevancia y autenticidad de los matches, y que la integridad de los datos del usuario y la seguridad de la plataforma sean inquebrantables. Este diseño sienta las bases para una aplicación que no solo conecta, sino que entiende y protege a sus usuarios.",
        "todoMarkdown": "### Próximos Pasos (Según el Rol de Javier - El Cerebro)\n-   **1. Refinar Requerimientos Detallados:** Trabajar con Agustina (o el cliente) para desglosar cada característica en historias de usuario y requerimientos funcionales específicos.\n-   **2. Especificar el Algoritmo de Matching:** Detallar los parámetros y pesos exactos que el motor de IA utilizará para calcular la compatibilidad, incluyendo consideraciones de privacidad y sesgos.\n-   **3. Diseñar Pruebas de Alucinación/Relevancia:** Crear un set de casos de prueba específicos para validar que el algoritmo de matching NO sugiere perfiles irrelevantes o que no cumplen las preferencias mínimas del usuario.\n-   **4. Definir Protocolos de Moderación IA:** Especificar los umbrales y tipos de contenido que el sistema de IA debe detectar, las acciones automáticas/manuales a seguir y los procesos de apelación.\n-   **5. Preparar \"Visto Bueno\" Final:** Documentar los criterios para la aprobación final del pase a producción, asegurando que todos los aspectos de seguridad, relevancia y experiencia de usuario se cumplan antes del lanzamiento."
      },
      "pdfUrl": "/api/runs/038348d3-e69c-406c-b7aa-dcee4f8c188c/steps/1/pdf",
      "readConfirmed": true
    },
    {
      "step": 2,
      "agentId": "fabricio",
      "status": "done",
      "finishedAt": "2026-02-15T03:24:20.475Z",
      "deliverables": {
        "outputJson": {
          "schemaSql": "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- Tabla de Usuarios\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    last_login_at TIMESTAMP WITH TIME ZONE\n);\n\n-- Tabla de Perfiles de Usuario\nCREATE TABLE profiles (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    name VARCHAR(255) NOT NULL,\n    age INTEGER,\n    gender VARCHAR(50),\n    bio TEXT,\n    location GEOMETRY(Point, 4326), -- Para coordenadas geográficas\n    preferences JSONB, -- Intereses, preferencias de búsqueda, etc.\n    profile_vector VECTOR(1536), -- Vector de embedding para el campo 'bio' y 'preferences'\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, tenant_id)\n);\n\n-- Índice para búsqueda de similitud en el vector del perfil\nCREATE INDEX ON profiles USING HNSW (profile_vector vector_l2_ops);\n\n-- Tabla de Fotos de Perfil\nCREATE TABLE profile_photos (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n    url TEXT NOT NULL,\n    is_main BOOLEAN DEFAULT FALSE,\n    order_index INTEGER DEFAULT 0,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tabla de Swipes (Me gusta/No me gusta)\nCREATE TABLE swipes (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    swiper_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    swiped_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    type VARCHAR(50) NOT NULL, -- 'like', 'dislike'\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(swiper_user_id, swiped_user_id, tenant_id)\n);\n\n-- Tabla de Matches (Coincidencias)\nCREATE TABLE matches (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    user1_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    user2_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    matched_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user1_id, user2_id, tenant_id), -- Asegura que un match solo existe una vez\n    CHECK (user1_id != user2_id)\n);\n\n-- Tabla de Conversaciones (Historial de Conversaciones)\nCREATE TABLE conversations (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    match_id UUID NOT NULL REFERENCES matches(id) ON DELETE CASCADE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(match_id, tenant_id)\n);\n\n-- Tabla de Mensajes\nCREATE TABLE messages (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,\n    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    sent_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    read_at TIMESTAMP WITH TIME ZONE\n);\n\n-- Tabla de Logs de Auditoría (para registrar interacciones con IA, tokens, etc.)\nCREATE TABLE audit_logs (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    tenant_id UUID NOT NULL,\n    user_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    action_type VARCHAR(255) NOT NULL, -- e.g., 'AI_PROMPT', 'DATA_ACCESS'\n    resource_type VARCHAR(255),\n    resource_id UUID,\n    details JSONB, -- Contiene prompt_version, input_tokens, output_tokens, response_data, etc.\n    ip_address INET,\n    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);",
          "estrategiaVectorizacion": {
            "datosAVectorizar": [
              "profiles.bio (texto libre del usuario)",
              "profiles.preferences (si se estructura como texto para búsqueda semántica)"
            ],
            "chunkingStrategy": "Para 'profiles.bio' y 'profiles.preferences', el chunking inicial será el texto completo, asumiendo que las bios en una app de citas son concisas. Si las descripciones se vuelven muy extensas, se podría considerar chunking por párrafo o sentencia. No se aplica chunking complejo para PDFs en este contexto de app de citas, sino para datos textuales de perfil.",
            "modeloEmbedding": "Se recomienda un modelo de embeddings de propósito general como OpenAI Embeddings (text-embedding-ada-002 o posterior) o un modelo de Hugging Face de alto rendimiento (ej., 'all-MiniLM-L6-v2') para convertir el texto en vectores numéricos. El tamaño del vector se define en 1536 para OpenAI ada.",
            "almacenamientoIndexacion": "Los vectores de los perfiles se almacenarán directamente en la tabla `profiles` utilizando la extensión `pgvector` de PostgreSQL. Se creará un índice HNSW (Hierarchical Navigable Small World) sobre la columna `profile_vector` para permitir búsquedas de similitud eficientes (k-NN).",
            "usoEnRAG": "Los vectores de perfil se utilizarán para: \n1. Búsqueda de similitud semántica: Encontrar usuarios con intereses o descripciones de perfil similares. \n2. Generación de recomendaciones: Sugerir perfiles basándose en la similitud vectorial con el perfil del usuario actual o con perfiles con los que ha interactuado positivamente. \n3. Asistencia a la conversación (futuro): Generar sugerencias de inicio de conversación o temas basados en los intereses vectorizados de ambos perfiles."
          },
          "dashboardPerformanceDB": {
            "description": "Dashboard para monitorear la salud y rendimiento de la base de datos, con foco en latencia de búsqueda vectorial e integridad de datos.",
            "metrics": [
              "Latencia de búsqueda vectorial (ms)",
              "Latencia de consultas SQL (ms)",
              "Uso del pool de conexiones de la base de datos (%)",
              "Uso de CPU de la DB (%)",
              "Uso de memoria de la DB (%)",
              "Operaciones de E/S de disco (IOPS)",
              "Número de conexiones activas",
              "Estado y tiempo de las últimas copias de seguridad",
              "Tasa de error de consultas",
              "Tamaño de la base de datos y crecimiento"
            ],
            "chartLabel": "Vector Search Latency (ms)",
            "chartData": [
              {
                "name": "Week 1",
                "value": 350
              },
              {
                "name": "Week 2",
                "value": 210
              },
              {
                "name": "Week 3",
                "value": 145
              },
              {
                "name": "Week 4",
                "value": 120
              }
            ]
          },
          "politicaRetencionDatos": {
            "usuariosInactivos": "Perfiles de usuarios inactivos por más de 12 meses serán anonimizados o archivados. Datos personales (email, nombre) serán eliminados tras 24 meses de inactividad, manteniendo datos agregados para análisis.",
            "mensajesConversaciones": "Mensajes y conversaciones se retendrán mientras la cuenta del usuario esté activa. Tras la eliminación o anonimización de la cuenta, los mensajes asociados serán eliminados o anonimizados tras 30 días.",
            "logsAuditoria": "Logs de auditoría se retendrán por 90 días para fines de seguridad y cumplimiento, con logs críticos (ej. acceso a datos sensibles, uso de IA) extendiéndose a 1 año.",
            "swipes": "Datos de swipes se retendrán por 6 meses para mejorar el algoritmo de matching, luego serán agregados y eliminados a nivel individual."
          }
        },
        "summaryMarkdown": "## Informe de Arquitectura de Datos - App de Citas\n\nComo Fabricio, el Arquitecto de Datos y Memoria, he diseñado el esquema de base de datos relacional y la estrategia de vectorización para la app de citas. El esquema SQL está normalizado para PostgreSQL, incluyendo tablas clave como `users`, `profiles`, `matches`, `conversations`, y `messages`, todas con soporte multi-tenant (`tenant_id`).\n\nSe ha definido una estrategia de vectorización para los campos `profiles.bio` y `profiles.preferences` utilizando `pgvector` para permitir búsquedas de similitud semántica y mejorar el motor de recomendaciones. Esto aborda la necesidad de procesar datos no estructurados de manera eficiente. Además, se ha diseñado una tabla `audit_logs` para capturar interacciones críticas, incluyendo el uso de IA y el registro de tokens de entrada/salida, cumpliendo con los requisitos de auditoría y rendimiento. Se propone un dashboard de performance para monitorear la latencia de búsqueda vectorial y la salud general de la DB, y se esboza una política de retención de datos para asegurar el cumplimiento y la gestión de la información.",
        "todoMarkdown": "### Próximos Pasos:\n- **Revisión del Schema SQL:** Presentar el `schema.sql` detallado a Javier (The Brain) y otros agentes para validación de entidades y atributos.\n- **Selección de Modelo de Embedding:** Confirmar el modelo de embedding específico (ej., OpenAI, Sentence Transformers) y el tamaño del vector a utilizar.\n- **Definición de Políticas de Backup:** Establecer un plan concreto de backups automáticos y recuperación de desastres, incluyendo frecuencia y ubicación de almacenamiento.\n- **Implementación de Pipelines de Ingestión:** Diseñar y empezar a implementar los pipelines para la ingestión de datos de perfil y la generación de sus embeddings.\n- **Configuración de Monitorización:** Configurar las herramientas de monitoreo para el `Dashboard de Performance de DB`, prestando especial atención a la latencia de búsqueda vectorial y el uso de recursos.\n- **Detallar Políticas de Privacidad:** Colaborar con el equipo para formalizar las políticas de privacidad y anonimización de datos, especialmente en relación con la retención y eliminación."
      },
      "pdfUrl": "/api/runs/038348d3-e69c-406c-b7aa-dcee4f8c188c/steps/2/pdf",
      "readConfirmed": true
    },
    {
      "step": 3,
      "agentId": "martin",
      "status": "done",
      "finishedAt": "2026-02-15T03:26:11.360Z",
      "deliverables": {
        "outputJson": {
          "n8nWorkflows": [
            {
              "name": "Registro y Perfil de Usuario",
              "description": "Gestiona la creación de nuevas cuentas de usuario, el almacenamiento de datos de perfil y la carga de fotos.",
              "trigger": "Webhook (HTTP POST /api/v1/users/register)",
              "nodes": [
                "Webhook (Recibe datos de usuario: nombre, email, password, fechaNacimiento, genero, preferencias, bio, fotos_base64)",
                "Validación de Datos (Email, edad mínima, formato de datos)",
                "Hash de Contraseña (si no lo gestiona un servicio de auth externo)",
                "Almacenar Usuario en DB (Integración con Fabricio's PostgreSQL: tabla 'users')",
                "Cargar Fotos a S3 (Decodificar base64, subir a AWS S3, obtener URLs públicas)",
                "Actualizar URLs de Fotos en DB (Actualizar tabla 'users' con URLs de S3)",
                "Enviar Email de Bienvenida (SendGrid API)",
                "Respuesta HTTP (Éxito/Error)",
                "Manejo de Errores (Try/Catch, Notificación a Slack)"
              ],
              "qualityChecklist": [
                "¿El workflow maneja errores (try/catch)?",
                "¿Las credenciales se llaman desde variables de entorno?",
                "¿Hay notificaciones de fallo configuradas?"
              ]
            },
            {
              "name": "Búsqueda y Matching de Perfiles",
              "description": "Permite a los usuarios buscar y descubrir perfiles compatibles basándose en preferencias y criterios.",
              "trigger": "Webhook (HTTP GET /api/v1/users/{userId}/matches)",
              "nodes": [
                "Webhook (Recibe userId y parámetros de filtro opcionales)",
                "Consultar Perfil de Usuario (Obtener preferencias del usuario de la DB)",
                "Consultar Perfiles Candidatos (Buscar en DB perfiles que coincidan con preferencias y filtros, excluyendo perfiles ya vistos o rechazados)",
                "Lógica de Matching (Node de código JS para aplicar reglas de compatibilidad o scoring)",
                "Respuesta HTTP (Lista de perfiles coincidentes)",
                "Manejo de Errores (Try/Catch, Notificación a Slack)"
              ],
              "qualityChecklist": [
                "¿El workflow maneja errores (try/catch)?",
                "¿Las credenciales se llaman desde variables de entorno?",
                "¿Hay notificaciones de fallo configuradas?"
              ]
            },
            {
              "name": "Envío de Mensajes y Notificaciones",
              "description": "Gestiona el envío de mensajes entre usuarios y dispara las notificaciones correspondientes.",
              "trigger": "Webhook (HTTP POST /api/v1/messages/send)",
              "nodes": [
                "Webhook (Recibe senderId, receiverId, messageContent)",
                "Validar Match (Verificar en DB si senderId y receiverId tienen un match activo)",
                "Almacenar Mensaje en DB (Tabla 'messages')",
                "Disparar Notificación (Llamada HTTP interna a /api/v1/notifications/trigger con receiverId y tipo de mensaje)",
                "Respuesta HTTP (Éxito/Error)",
                "Manejo de Errores (Try/Catch, Notificación a Slack)"
              ],
              "qualityChecklist": [
                "¿El workflow maneja errores (try/catch)?",
                "¿Las credenciales se llaman desde variables de entorno?",
                "¿Hay notificaciones de fallo configuradas?"
              ]
            },
            {
              "name": "Gestión de Notificaciones Push/Email",
              "description": "Centraliza el envío de notificaciones a través de diferentes canales (push, email).",
              "trigger": "Webhook (HTTP POST /api/v1/notifications/trigger)",
              "nodes": [
                "Webhook (Recibe userId, type, payload)",
                "Consultar Preferencias de Notificación (De la DB, para saber cómo notificar al usuario)",
                "Componer Mensaje de Notificación (Basado en 'type' y 'payload')",
                "Enviar Push Notification (Firebase Cloud Messaging API via HTTP Request)",
                "Enviar Email (SendGrid API via HTTP Request, si aplica)",
                "Respuesta HTTP (Éxito/Error)",
                "Manejo de Errores (Try/Catch, Notificación a Slack, lógica de reintento)"
              ],
              "qualityChecklist": [
                "¿El workflow maneja errores (try/catch)?",
                "¿Las credenciales se llaman desde variables de entorno?",
                "¿Hay notificaciones de fallo configuradas?"
              ]
            }
          ],
          "apiEndpoints": [
            {
              "path": "/api/v1/users/register",
              "method": "POST",
              "description": "Registra un nuevo usuario y crea su perfil."
            },
            {
              "path": "/api/v1/users/{userId}/matches",
              "method": "GET",
              "description": "Obtiene una lista de perfiles coincidentes para un usuario específico."
            },
            {
              "path": "/api/v1/messages/send",
              "method": "POST",
              "description": "Envía un mensaje de un usuario a otro."
            },
            {
              "path": "/api/v1/notifications/trigger",
              "method": "POST",
              "description": "Endpoint interno para disparar notificaciones push o por email."
            }
          ],
          "integrations": [
            {
              "name": "Database",
              "service": "PostgreSQL (asumido de Fabricio)",
              "purpose": "Almacenamiento de perfiles de usuario, matches, mensajes, preferencias."
            },
            {
              "name": "Email Service",
              "service": "SendGrid",
              "purpose": "Envío de emails de bienvenida, recuperación de contraseña, notificaciones."
            },
            {
              "name": "File Storage",
              "service": "AWS S3",
              "purpose": "Almacenamiento escalable de fotos de perfil de usuario."
            },
            {
              "name": "Push Notifications",
              "service": "Firebase Cloud Messaging (FCM)",
              "purpose": "Envío de notificaciones en tiempo real a dispositivos móviles (nuevos matches, mensajes)."
            },
            {
              "name": "Monitoring & Alerts",
              "service": "Slack",
              "purpose": "Notificaciones de fallos críticos en los workflows."
            }
          ],
          "errorHandlingStrategy": {
            "globalErrorWorkflow": true,
            "nodeLevelErrorHandling": "Try/Catch en nodos críticos (DB, APIs externas)",
            "retryLogic": "Configurado para llamadas a APIs externas (S3, SendGrid, FCM) con reintentos exponenciales.",
            "notifications": "Alertas a un canal de Slack para errores críticos y fallos de workflows."
          },
          "deploymentStrategy": {
            "n8nInstance": "Instancia de n8n en la nube (ej. n8n.cloud o self-hosted en AWS/GCP)",
            "versionControl": "Workflows exportados y versionados en un repositorio Git.",
            "monitoring": "Uptime del servicio n8n, métricas de ejecución de workflows, tasa de fallos."
          }
        },
        "summaryMarkdown": "## Resumen de la Orquestación Técnica para la App de Citas\n\nComo 'El Plomero', he diseñado la arquitectura de orquestación técnica para la aplicación de citas, conectando la lógica de negocio (asumida de Javier) con la persistencia de datos (Fabricio) y los servicios externos. Se han definido cuatro flujos de trabajo clave en n8n:\n\n1.  **Registro y Perfil de Usuario**: Maneja la creación de cuentas, almacenamiento de datos y carga de fotos a AWS S3.\n2.  **Búsqueda y Matching de Perfiles**: Procesa la lógica para encontrar usuarios compatibles.\n3.  **Envío de Mensajes y Notificaciones**: Gestiona la comunicación entre usuarios y dispara alertas.\n4.  **Gestión de Notificaciones Push/Email**: Centraliza el envío de notificaciones a través de FCM y SendGrid.\n\nEstos flujos se integrarán con una base de datos PostgreSQL (provista por Fabricio), servicios de correo electrónico (SendGrid), almacenamiento de archivos (AWS S3) y notificaciones push (Firebase Cloud Messaging). Se ha puesto un énfasis particular en el manejo robusto de errores, incluyendo lógica de reintento, monitoreo y alertas en Slack para asegurar la fiabilidad del servicio y cumplir con los estándares de calidad.",
        "todoMarkdown": "### Próximos Pasos para Martín:\n\n-   **Configuración Inicial:**\n    -   Configurar una instancia de n8n y asegurar el acceso.\n    -   Definir y cargar las credenciales necesarias (DB, SendGrid, AWS S3, FCM, Slack) como variables de entorno seguras en n8n.\n-   **Desarrollo de Workflows:**\n    -   Implementar el workflow 'Registro y Perfil de Usuario' en n8n, incluyendo la validación de datos y la integración con la base de datos de Fabricio y AWS S3 para fotos.\n    -   Crear el workflow 'Búsqueda y Matching de Perfiles', conectando con la base de datos para recuperar y procesar perfiles.\n    -   Desarrollar el workflow 'Envío de Mensajes y Notificaciones', asegurando la validación de matches y el almacenamiento de mensajes.\n    -   Construir el workflow 'Gestión de Notificaciones Push/Email' para disparar alertas a través de FCM y SendGrid.\n-   **Manejo de Errores y Calidad:**\n    -   Integrar manejo de errores (Try/Catch) en cada workflow crítico.\n    -   Configurar un workflow global de manejo de errores y notificaciones de Slack para fallos.\n    -   Añadir lógica de reintento para las llamadas a APIs externas.\n-   **Pruebas:**\n    -   Realizar pruebas de integración end-to-end para cada workflow y sus endpoints asociados.\n    -   Documentar los workflows de n8n con descripciones claras y ejemplos de payload."
      },
      "pdfUrl": "/api/runs/038348d3-e69c-406c-b7aa-dcee4f8c188c/steps/3/pdf",
      "readConfirmed": true
    },
    {
      "step": 4,
      "agentId": "damian",
      "status": "in_review",
      "finishedAt": "2026-02-15T03:32:35.397Z",
      "deliverables": {
        "outputJson": {
          "matrizDeRolesYPermisos": {
            "description": "Matriz inicial de Roles y Permisos (RBAC) para la aplicación de citas, diseñada bajo el principio de menor privilegio para proteger los datos de los usuarios y la funcionalidad del sistema.",
            "roles": [
              {
                "roleName": "Usuario Registrado",
                "permissions": [
                  "profile:read_own",
                  "profile:update_own",
                  "profile:delete_own",
                  "profile:read_other",
                  "profile:report_other",
                  "profile:block_other",
                  "messages:send",
                  "messages:receive",
                  "messages:delete_own",
                  "matches:view",
                  "matches:like",
                  "matches:dislike",
                  "settings:privacy_manage"
                ]
              },
              {
                "roleName": "Moderador",
                "inherits": [
                  "Usuario Registrado"
                ],
                "permissions": [
                  "content:review_photos",
                  "content:review_text",
                  "content:remove",
                  "user:block",
                  "user:unblock",
                  "user:suspend",
                  "report:view_all",
                  "report:resolve"
                ]
              },
              {
                "roleName": "Administrador",
                "inherits": [
                  "Moderador"
                ],
                "permissions": [
                  "user:manage_all",
                  "system:config_read",
                  "system:config_update",
                  "audit:logs_read_all",
                  "data:export_limited_pii",
                  "platform:maintenance_mode_toggle"
                ]
              },
              {
                "roleName": "Equipo de Desarrollo (Dev)",
                "permissions": [
                  "code:read_all",
                  "code:write_dev_staging",
                  "db:schema_read_dev_staging",
                  "db:data_read_dev_staging_sanitized",
                  "secrets:access_dev_staging_read_only",
                  "logs:read_all_environments",
                  "infra:deploy_dev_staging"
                ]
              },
              {
                "roleName": "Cuentas de Servicio (Service Accounts)",
                "permissions": [
                  "api:profile_update_status",
                  "api:notification_send_message",
                  "api:image_process",
                  "db:internal_read_write_specific_tables"
                ]
              }
            ]
          },
          "reporteDeVulnerabilidadesInicial": {
            "description": "Evaluación inicial de áreas de riesgo de seguridad para la aplicación de citas, identificando puntos críticos a abordar en las próximas fases.",
            "findings": [
              "**Secrets Hardcodeados (CRÍTICO):** Se ha identificado la necesidad imperativa de auditar el repositorio de código y la configuración en busca de claves API, tokens de autenticación, credenciales de base de datos u otros secretos hardcodeados. Su presencia es un riesgo de seguridad crítico y debe ser mitigada inmediatamente mediante el uso de una bóveda de secretos.",
              "**Control de Acceso Inadecuado (ALTO):** La correcta implementación de la matriz RBAC es fundamental. Se debe garantizar que no existan vulnerabilidades de Broken Access Control que permitan a los usuarios acceder a recursos o realizar acciones fuera de sus permisos definidos. Esto incluye validación en el backend para todos los endpoints.",
              "**Almacenamiento y Cifrado de Datos Sensibles (ALTO):** Los datos personales identificables (PII) de los usuarios, como fotos, preferencias y mensajes, deben ser cifrados tanto en reposo (en la base de datos y almacenamiento de archivos) como en tránsito (mediante HTTPS/TLS). La implementación de Row Level Security (RLS) es esencial para la privacidad.",
              "**Vulnerabilidades de Inyección (ALTO):** Riesgo inherente en cualquier aplicación web. Se deben implementar protecciones contra SQL Injection, XSS (Cross-Site Scripting), Command Injection y otras formas de inyección en todas las capas de la aplicación, especialmente en la interacción con la base de datos y la renderización de contenido generado por el usuario.",
              "**Endpoints de API Inseguros (MEDIO):** Todos los endpoints de la API deben estar protegidos con autenticación y autorización robustas. Se requiere la implementación de rate limiting para prevenir ataques de fuerza bruta y denegación de servicio, así como la validación de esquemas de entrada para evitar payloads malformados."
            ],
            "status": "Evaluación Inicial - Pendiente de Auditoría Detallada y Pruebas de Penetración"
          },
          "bovedaDeSecretosRecomendaciones": {
            "description": "Recomendaciones para la gestión segura del ciclo de vida de los secretos (credenciales, claves API, tokens) de la aplicación.",
            "recommendations": [
              "**Plataforma de Gestión de Secretos:** Adoptar y configurar un servicio de gestión de secretos dedicado (ej. AWS Secrets Manager, HashiCorp Vault, Azure Key Vault, GCP Secret Manager) para centralizar el almacenamiento y acceso a todos los secretos.",
              "**Rotación Automática de Claves:** Implementar políticas de rotación automática y regular para las credenciales de base de datos, claves API y otros secretos sensibles. Esto reduce la ventana de exposición en caso de compromiso.",
              "**Acceso Basado en Roles/Identidad:** Los servicios y usuarios deben acceder a los secretos utilizando sus identidades de IAM, aplicando el principio de menor privilegio. Evitar la propagación de secretos a través de variables de entorno no protegidas o archivos de configuración.",
              "**Auditoría de Acceso a Secretos:** Configurar el logging y la auditoría detallada de todos los intentos de acceso a la bóveda de secretos, incluyendo éxitos y fallos, para detectar y responder a actividades sospechosas.",
              "**Separación de Entornos:** Mantener secretos completamente separados para los entornos de desarrollo, staging y producción, con políticas de acceso estrictas para cada uno."
            ]
          }
        },
        "summaryMarkdown": "## Informe de Seguridad - Fase 1: Planificación y Diseño (Damián - The Guardian)\n\nComo The Guardian, he completado la fase inicial de revisión de seguridad para la aplicación de citas, enfocándome en sentar las bases para una plataforma robusta y confiable. Mi misión es salvaguardar la plataforma y los datos de los clientes, asegurando la confidencialidad, integridad y disponibilidad.\n\n### Hitos Alcanzados:\n\n*   **Matriz de Roles y Permisos (RBAC):** Se ha definido una matriz exhaustiva de roles (Usuario Registrado, Moderador, Administrador, Equipo de Desarrollo, Cuentas de Servicio) con permisos detallados. Esto garantiza la aplicación del **principio de menor privilegio**, fundamental para limitar el acceso a los datos y funcionalidades sensibles.\n*   **Evaluación Inicial de Vulnerabilidades:** He realizado una inspección preliminar identificando áreas críticas de riesgo como la posible existencia de secretos hardcodeados, la necesidad de un robusto control de acceso, el cifrado de datos sensibles (PII) en reposo y tránsito, y la protección contra vulnerabilidades de inyección y APIs inseguras.\n*   **Recomendaciones para Bóveda de Secretos:** Se han establecido directrices claras para la gestión segura de credenciales y claves API, haciendo hincapié en el uso de un Secret Manager dedicado, la rotación automática de claves y el acceso basado en identidad.\n\nEsta fase ha establecido un marco de seguridad inicial, priorizando la protección de la información del usuario y la resiliencia del sistema frente a posibles ataques. La seguridad se integra desde el diseño, anticipando y mitigando riesgos antes de la implementación.",
        "todoMarkdown": "### Próximos Pasos para The Guardian:\n\n-   **Auditoría de Código Estática (SAST):** Ejecutar herramientas SAST en el repositorio de código base para identificar y remediar cualquier secreto hardcodeado, dependencias vulnerables y patrones de codificación inseguros.\n-   **Configuración de RLS:** Colaborar activamente con Fabricio (The Memory) para diseñar e implementar las políticas de Row Level Security (RLS) en la base de datos, asegurando un control granular sobre el acceso a los datos sensibles de los usuarios.\n-   **Integración de Secret Manager:** Trabajar con Martín (The Plumber) para integrar un sistema de gestión de secretos (ej. HashiCorp Vault, AWS Secrets Manager) en la arquitectura, definiendo los flujos de acceso seguro para los microservicios y el equipo de desarrollo.\n-   **Modelado de Amenazas:** Realizar un taller de modelado de amenazas para identificar vectores de ataque específicos y diseñar contramedidas para los componentes clave de la aplicación.\n-   **Plan de Respuesta a Incidentes (IRP):** Desarrollar un borrador del Plan de Respuesta a Incidentes de Seguridad, incluyendo procedimientos de detección, contención, erradicación y recuperación.\n-   **Revisión de Cumplimiento Normativo:** Iniciar la evaluación de los requisitos de cumplimiento normativo (ej. GDPR) para asegurar que la gestión y protección de datos personales esté alineada con las regulaciones aplicables."
      },
      "pdfUrl": "/api/runs/038348d3-e69c-406c-b7aa-dcee4f8c188c/steps/4/pdf"
    },
    {
      "step": 5,
      "agentId": "agustina",
      "status": "pending"
    }
  ],
  "artifacts": []
}